module.exports = grammar({
  name: 'quickbms',

  extras: $ => [
    /\s|\\\r?\n/,
    $.comment,
  ],

  rules: {
    source_file: $ => repeat($._top_statement),
    _top_statement: $ => choice(
      $._statement,
      $.function_declaration
    ),
    function_declaration: $ => seq(
      $.startfunction,
      field("name", $.identifier),
      field("body", repeat($._statement)),
      $.endfunction,
    ),
    _statement: $ => choice(
      $.print_statement,
      $.set_statement,
      $.function_call_statement,
      $.endian_statement,
      $.idstring_statement,
      $.if_statement,
      $.for_statement,
      $.break_statement,
      $.continue_statement,
      $.goto_statement,
      $.cleanexit_statement,
      $.findloc_statement,
      $.get_statement,
      $.math_statement,
      $.log_statement,
      $.getarray_statement,
      $.putarray_statement,
      $.string_statement,
      $.encryption_statement,
      $.reverseshort_statement,
      $.reverselong_statement,
      $.reverselonglong_statement,
      $.filexor_statement,
      $.append_statement,
      $.getvarchr_statement,
    ),
    set_statement: $ => seq(
      $.set,
      field("variable", $.identifier),
      field("type", optional(choice($.type, $.question_mark))),
      field("value", choice($._expression, $.question_mark)),
    ),
    print_statement: $ => seq(
      $.print,
      field("value", $._expression)
    ),
    function_call_statement: $ => seq(
      $.callfunction,
      field("name", $.identifier),
      field("keep_var", optional($.integer_literal)),
    ),
    endian_statement: $ => seq(
      $.endian,
      field("type", $._endian_type),
      field("value", optional($._expression)),
    ),
    idstring_statement: $ => seq(
      $.idstring,
      field("filenum", optional($._expression)),
      field("magic", $.string_literal),
    ),
    if_statement: $ => seq(
      $.if,
      field("left_expression", $._expression),
      field("comparison", $.comparison),
      field("right_expression", $._expression),
      field("body", repeat($._statement)),
      field("else_clauses", repeat(choice(
        $.elif_statement,
        $.else_statement
      ))),
      $.endif
    ),
    elif_statement: $ => seq(
      $.elif,
      field("left_expression", $._expression),
      field("comparison", $.comparison),
      field("right_expression", $._expression),
      field("body", repeat($._statement)),
    ),
    else_statement: $ => seq(
      $.else,
      field("body", repeat($._statement)),
    ),
    for_statement: $ => seq(
      $.for,
      optional(seq(
        field("variable", $._expression),
        field("operation", $.operation),
        field("value", $._expression),
        field("comparison", $.comparison),
        field("right_expression", $._expression),
      )),
      field("body", repeat($._statement)),
      $.next_statement,
    ),
    next_statement: $ => seq(
      $.next,
      optional(seq(
        field("variable", $._expression),
        optional(seq(
          field("operation", $.operation),
          field("value", $._expression),
        )),
      )),
    ),
    break_statement: $ => seq(
      $.break,
      field("label", optional($._expression)),
    ),
    continue_statement: $ => seq(
      $.continue,
      field("label", optional($._expression)),
    ),
    goto_statement: $ => seq(
      $.goto,
      field("offset", $._expression),
      field("file_num", optional($._expression)),
      field("type", optional($._goto_type)),
    ),
    cleanexit_statement: $ => seq(
      $.cleanexit
    ),
    findloc_statement: $ => seq(
      $.findloc,
      field("variable", $._expression),
      field("type", $.type),
      field("string", $._expression),
      optional(seq(
        field("file_num", $._expression),
        optional(seq(
          field("error_value", $._expression),
          optional(seq(
            field("end_off", $._expression),
          )),
        )),
      )),
    ),
    get_statement: $ => seq(
      $.get,
      field("variable", $._expression),
      field("type", $.type),
      field("file_num", optional($._expression)),
    ),
    math_statement: $ => seq(
      $.math,
      field("variable", $._expression),
      field("operation", $.operation),
      field("expression", $._expression),
    ),
    log_statement: $ => seq(
      $.log,
      field("name", $._expression),
      field("offset", $._expression),
      field("size", $._expression),
      field("file_number", optional($._expression)),
    ),
    getarray_statement: $ => seq(
      $.getarray,
      field("variable", $._expression),
      field("array", $._expression),
      field("index", $._expression),
    ),
    putarray_statement: $ => seq(
      $.putarray,
      field("array", $._expression),
      field("index", $._expression),
      field("variable", $._expression),
    ),
    string_statement: $ => seq(
      $.string,
      field("left_variable", $._expression),
      field("operation", $.operation),
      field("right_variable", $._expression),
    ),
    encryption_statement: $ => seq(
      $.encryption,
      field("algorithm", $.identifier),
      field("key", $._expression),
      optional(choice(
        field("ivec", $._expression),
        seq(
          field("ivec", $._expression),
          field("mode", $._expression),
        ),
        seq(
          field("ivec", $._expression),
          field("mode", $._expression),
          field("key_length", $._expression),
        ),
      )),
    ),
    reverseshort_statement: $ => seq(
      $.reverseshort,
      field("variable", $._expression),
      field("endian", optional($._endian_type)),
    ),
    reverselong_statement: $ => seq(
      $.reverselong,
      field("variable", $._expression),
      field("endian", optional($._endian_type)),
    ),
    reverselonglong_statement: $ => seq(
      $.reverselonglong,
      field("variable", $._expression),
      field("endian", optional($._endian_type)),
    ),
    filexor_statement: $ => seq(
      $.filexor,
      field("sequence", $._expression),
      field("offset", optional($._expression)),
      // field("file_number", optional($._expression)),
    ),
    append_statement: $ => seq(
      $.append,
      field("direction", optional(choice("-1", "0", "1", "2"))),
    ),
    getvarchr_statement: $ => seq(
      $.getvarchr,
      field("left_variable", $._expression),
      field("right_variable", $._expression),
      field("offset", $._expression),
      field("type", optional($.type)),
      "\n", // Note: needed to avoid a conflict with a string statement following a getvarchr statement that does not have a type
    ),
    comparison: $ => choice(
      "<",
      ">",
      "<=",
      ">=",
      "!=",
      "<>",
      "!==",
      "==",
      "=",
      "==="
    ),
    operation: $ => choice(
      "=",
      "+=",
      "/=",
      "*",
      "<<",
      "u<<",
      "~",
      "n",
      "a",
      "u/",
      "v",
      "+",
      "-",
    ),
    _goto_type: $ => choice(
      $.seek_set,
      $.seek_cur,
      $.seek_end,
    ),
    type: $ => choice(
      $.long,
      $.asize,
      $.string,
      $.binary,
      $.unicode,
      $.byte,
    ),
    _endian_type: $ => choice(
      $.little,
      $.intel,
      $.big,
      $.network,
      $.swap,
      $.change,
      $.invert,
      $.guess,
      $.guess16,
      $.guess64,
      $.guess24,
      $.save,
      $.store
    ),
    _expression: $ => choice(
      $.string_literal,
      $.integer_literal,
      $.identifier,
    ),

    print: $ => /[Pp][Rr][Ii][Nn][Tt]/,
    set: $ => /[Ss][Ee][Tt]/,
    startfunction: $ => /[Ss][Tt][Aa][Rr][Tt][Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/,
    endfunction: $ => /[Ee][Nn][Dd][Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/,
    callfunction: $ => /[Cc][Aa][Ll][Ll][Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/,
    long: $ => /[Ll][Oo][Nn][Gg]/,
    asize: $ => /[Aa][Ss][Ii][Zz][Ee]/,
    string: $ => /[Ss][Tt][Rr][Ii][Nn][Gg]/,
    binary: $ => /[Bb][Ii][Nn][Aa][Rr][Yy]/,
    unicode: $ => /[Uu][Nn][Ii][Cc][Oo][Dd][Ee]/,
    byte: $ => /[Bb][Yy][Tt][Ee]/,
    endian: $ => /[Ee][Nn][Dd][Ii][Aa][Nn]/,
    little: $ => /[Ll][Ii][Tt][Tt][Ll][Ee]/,
    intel: $ => /[Ii][Nn][Tt][Ee][Ll]/,
    big: $ => /[Bb][Ii][Gg]/,
    network: $ => /[Nn][Ee][Tt][Ww][Oo][Rr][Kk]/,
    swap: $ => /[Ss][Ww][Aa][Pp]/,
    change: $ => /[Cc][Hh][Aa][Nn][Gg][Ee]/,
    invert: $ => /[Ii][Nn][Vv][Ee][Rr][Tt]/,
    guess: $ => /[Gg][Uu][Ee][Ss][Ss]/,
    guess16: $ => /[Gg][Uu][Ee][Ss][Ss]16/,
    guess64: $ => /[Gg][Uu][Ee][Ss][Ss]64/,
    guess24: $ => /[Gg][Uu][Ee][Ss][Ss]24/,
    save: $ => /[Ss][Aa][Vv][Ee]/,
    store: $ => /[Ss][Tt][Oo][Rr][Ee]/,
    idstring: $ => /[Ii][Dd][Ss][Tt][Rr][Ii][Nn][Gg]/,
    if: $ => /[Ii][Ff]/,
    elif: $ => /[Ee][Ll][Ii][Ff]/,
    else: $ => /[Ee][Ll][Ss][Ee]/,
    endif: $ => /[Ee][Nn][Dd][Ii][Ff]/,
    for: $ => /[Ff][Oo][Rr]/,
    next: $ => /[Nn][Ee][Xx][Tt]/,
    break: $ => /[Bb][Rr][Ee][Aa][Kk]/,
    continue: $ => /[Cc][Oo][Nn][Tt][Ii][Nn][Uu][Ee]/,
    goto: $ => /[Gg][Oo][Tt][Oo]/,
    seek_set: $ => /[Ss][Ee][Ee][Kk]_[Ss][Ee][Tt]/,
    seek_cur: $ => /[Ss][Ee][Ee][Kk]_[Cc][Uu][Rr]/,
    seek_end: $ => /[Ss][Ee][Ee][Kk]_[Ee][Nn][Dd]/,
    cleanexit: $ => /[Cc][Ll][Ee][Aa][Nn][Ee][Xx][Ii][Tt]/,
    findloc: $ => /[Ff][Ii][Nn][Dd][Ll][Oo][Cc]/,
    get: $ => /[Gg][Ee][Tt]/,
    math: $ => /[Mm][Aa][Tt][Hh]/,
    log: $ => /[Ll][Oo][Gg]/,
    getarray: $ => /[Gg][Ee][Tt][Aa][Rr][Rr][Aa][Yy]/,
    putarray: $ => /[Pp][Uu][Tt][Aa][Rr][Rr][Aa][Yy]/,
    encryption: $ => /[Ee][Nn][Cc][Rr][Yy][Pp][Tt][Ii][Oo][Nn]/,
    reverseshort: $ => /[Rr][Ee][Vv][Ee][Rr][Ss][Ee][Ss][Hh][Oo][Rr][Tt]/,
    reverselong: $ => /[Rr][Ee][Vv][Ee][Rr][Ss][Ee][Ll][Oo][Nn][Gg]/,
    reverselonglong: $ => /[Rr][Ee][Vv][Ee][Rr][Ss][Ee][Ll][Oo][Nn][Gg][Ll][Oo][Nn][Gg]/,
    filexor: $ => /[Ff][Ii][Ll][Ee][Xx][Oo][Rr]/,
    append: $ => /[Aa][Pp][Pp][Ee][Nn][Dd]/,
    getvarchr: $ => /[Gg][Ee][Tt][Vv][Aa][Rr][Cc][Hh][Rr]/,
    question_mark: $ => /\?/,

    identifier: $ => /[a-zA-Z_\\]+[a-zA-Z0-9_\-\\]*/,
    integer_literal: $ => /(\-?(0x)?[0-9a-fA-F]+)|(\-?[0-9]+)/,
    string_literal: $ => seq(
      '"',
      repeat(token.immediate(prec(1, /[^"\n]+/))),
      '"',
    ),

    comment: $ => token(choice(
      seq('#', /(\\(.|\r?\n)|[^\\\n])*/),
      seq('//', /(\\(.|\r?\n)|[^\\\n])*/),
      seq(
        '/*',
        /[^*]*\*+([^/*][^*]*\*+)*/,
        '/'
      )
    )),
  }
});

